# 오늘의 목표는? 그래프!
- 챕터8. p.266 ~ 349

## 그래프는 내용이 많으니.. 이번주는 전반부!
- union-find, topologicalSort, dijkstra 부분을 중심으로 살펴보자.

## 우선 그래프의 표현 방법부터..
- 그래프는 다음과 같이 3가지 방법으로 표현한다.
1. EDGE LIST: 간선을 중심으로 그래프를 표현하는 방법
    - 배열을 사용하여 출발 정점, 도착 정점을 저장해서 간선을 표현한다.
    - 가중치가 있는 경우, 출발점, 도착점, 가중치를 저장해서 가중치 간선을 표현한다.
    
    - 즉, GRAPH[M][2]로 M개 간선을 가진 그래프를 표현한다.
    - 엣지 리스트는 간선 정보를 순서없이 저장하므로 구현하기 쉬우나,</br>
    특정 정점과 관련된 간선을 탐색하기는 어렵다.
    - 엣지 리스트는 노드 사이의 최단 거리를 구하는 벨만-포드,</br>
    MST를 찾는 크루스칼 알고리즘에 사용한다.

2. ADJACENCY MATRIX : 2차원 배열을 자료구조로 이용한 표현 방법
    - 출발 정점을 행으로 도착 정점을 열로 표현하여</BR>
    해당 간선이 존재하면 해당 칸에 값을 부여한다.
    - 가중치가 존재하면 임의의 값 대신 가중치를 적어넣는다.
    
    - EX) 1에서 2, 1에서3, 3에서 4로 향하는 간선이 존재하면</BR>
    각각 GRAPH[1][2] = 1, GRAPH[1][3] = 1, GRAPH[3][4] = 1로 부여
    - 이 방법도 구현이 쉽고, 두 정점의 연결 여부, 가중치 값을 빠르게 찾아내는</BR> 장점이 있으나, 특정 정점의 간선을 찾으려면 N(정점 크기)만큼 접근해야 한다.

3. ADJACENCY LIST : 2차원 벡터를 자료구조로 이용한 표현 방법
    - vector<vector<int>> GRAPH로 정의한다.
    - i번 정점과 연결된 정점을 GRAPH[i].push_back(v)으로 더하는 방식으로 표현한다. 
    - 가중치가 존재하는 경우 vector<int> 대신 vector<pair<int, int>>를 사용한다.
    - 정점의 개수가 고정되어 있는 경우 벡터 배열(vector<int> VERTEX[N])로 선언한다.

    - 다른 구현 방법에 비해 복잡한 편이나, 
    특정 정점에 대한 간선을 탐색 하는 시간이 빠르고,</br> 
    정점 개수가 많아도 공간 효율이 좋아 메모리 초과가 발생하지 않는다.
    - 그래서, 실제 코딩테스트는 인접 리스트를 이용한 그래프 구현을 선호한다.

## 백준 연습문제

- P1717 집합 표현하기(union-find)
- P1516 게임 개발하기(topological-sort)
- P1948 임계 경로 구하기(topological-sort, 플래티넘!)
- P1753 최단 경로 구하기(dijkstra)
- P1854 K번째 최단 경로 찾기(dijkstra, 플래티넘!)